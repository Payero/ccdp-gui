'''
Created on Jun 19, 2017

@author: oeg
'''
from modules.CcdpModule import CcdpModule
import ccdp_utils

class CsvDisplay(CcdpModule):
  '''
  Class used to execute a task using a JSON representaion of a CcdpTaskRequest.
  It is intented to simplify the module development.  The configuration passed 
  to this module should be a valid CcdpTaskRequest such as:
  
  {
    "name" :          the human readable name
    "description" :   some text describing what the module does
    "state" :         the current processing state of the task
    "retries" :       how many times to retry before failing the task
    "command" :       a list of entries to build the command
    "configuration" : additional information to pass to the task
    "task-id" :       a unique identifier for this task
    "class-name" :    the class or module to load
    "node-type" :     the type of resource to use to run this task
    "reply-to" :      a destination to send updates with the task progress
    "host-id" :       if assigned to a particular host, what is the id
    "submitted" :     whether or not this task has been submitted
    "cpu" :           the amount of CPU this task requires
    "mem" :           the amount of memory this task requires
    "input-ports" :   a list of tasks ids that will send data to this task
    "output-ports" :  a list of task ids that this task will send data to
    "session-id" :    the session used to run this task
    "launched-time" : when was this task launched
  }
  '''
  
  def __init__(self, params):
    '''
    Instantiates a new ccdp module object configured to start receiving command
    messages from the ThreadController.  The arguments is a dictionary 
    containing the information necessary to connect to the message broker. The
    task id is used as the queue to receive messages from the ThreadController
  

    Inputs:
      - args['broker_host']:  The message broker's ip address or hostname 
      - args['broker_port']   The message broker's port number
      - args['task_id']:      The UUID used as the queue to receive messages

    '''
    super(self.__class__, self).__init__(params)
    self._logger.info("Starting the new class")
    self.__handle = None
    
    
  def _on_message(self, msg):
    '''
    Receives a message from the ThreadController or the ccdp-engine itself.
    Each message has a msg-type field either as an integer (from the 
    ccdp-engine) or as a string (from the ThreadController).

    The only message we are interested from the ccdp-engine are the TASK_UPDATE
    messages.
    
    Messages:
      - Start:
          {'msg-type': 'COMMAND', 'data':{'action': 'START', 'task': < task >}}
      - Pause:
          {'msg-type': 'COMMAND', 'data':{'action': 'START', 'task': < task >}}
      - Stop:
          {'msg-type': 'COMMAND', 'data':{'action': 'START', 'task': < task >}}
      - TaskUpdate: 
          {'msg-type': 'TASK_UPDATE', 'data':{'task':< task >}}
      - Error: 
          {'msg-type': 'MESSAGE', 'data':{'type':'ERROR', 'message': < error > }}
      - Message:
          {'msg-type': 'MESSAGE', 'data':{'type':'MESSAGE', 'message': < msg > }}
          
    Inputs:
      - json_msg: the json message sent by either the ccdp-engine or the 
                  ThreadController

    '''
    self._done_processing = False
    self._logger.info("Got some message: %s" % msg)
    self.__handle.write(",".join(msg))
    self.__handle.write("\n")
    
    self._done_processing = True
    
    # If there are no more incoming messages, then we are done so notify 
    if self._predecesor_done:
      self._send_done_processing()
      


    
  def _start_module(self, task):
    '''
    Gets a command message with the action set to 'START'.  The task is a JSON
    representation of a CcdpTaskRequest object containing all the information
    needed to execute a task.

    Inputs:
      - task: the JSON representation of a CcdpTaskRequest

    CcdpTaskRequest Example:

    {
      "name" : "human readable name",
      "description" : "Short descrption of what this does (tooltip)",
      "retries" : 3,
      "command" : [ a list of commands generated by the GUI ],
      "configuration" : {key-value pairs of items used to configure this module},
      "task-id" : "some UUID",
      "session-id" : "Web Browser session id",
      "node-type" : "DEFAULT",
      "reply-to" : "the name of the queue to send updates back to the GUI",
      "input-ports" : [ ],
      "output-ports" : [ {
        "port-id" : "the uuid of this port",
        "from-port" : [ ],
        "to-port" : [ a list of ports to send results to ]
      } ]
    }
    '''
    self._logger.info("Starting module")
    url = task['configuration']['output-url']
    if url.startswith('file://'):
      self.__fname = url[len('file://'):]
      self._logger.info("Saving results in %s" % self.__fname)
      self.__handle = file(self.__fname, 'w')  
      
  def _pause_module(self):
    '''
    Pauses the execution or processing of the task.
    '''
    self._logger.info("Starting module")
  
  def _stop_module(self):
    '''
    Stops the execution or processing of the task.  Once this method is invoked
    all the connections are terminated and this module will no longer be 
    available.
    '''
    self._logger.info("Starting module")
    if self.__handle != None:
      self.__handle.close()


    
if __name__ == '__main__':
  '''
  Runs the module from the command line.  This is not actually necessary as the
  modules are instantiated by the CcdpModuleLauncher, but is usefull during
  development.
  '''
  from optparse import OptionParser
  
  desc = "Cloud Computing Data Processing module.  This a module used \n"
  desc += "to perform a specific task and send and receive results to/from \n"
  desc += "other modules.  It uses the broker host/port to communicate "
  desc += "with other modules"

  parser = OptionParser(usage="usage: %prog [options] args",
            version="%prog 1.0",
            description=desc)
  
  parser.add_option('-b', '--broker-host',
            dest='broker_host',
            default='localhost',
            help='IP address of the messaging broker if required',)

  parser.add_option('-p', '--broker-port',
            dest='broker_port',
            default=61616,
            help='Port number of the messaging broker if necessary',)

  parser.add_option('-t', '--task-id',
            dest='task_id',
            default=None,
            help='The unique task-id which is also used as the channel to receive messages',)

 
   
  (options, args) = parser.parse_args()
  # it expects a dictionary 
  opts = vars(options)
  CsvDisplay(opts)
   
  
